package hellojpa;

import javax.persistence.*;

/**
 * 권장하는 식별자 전략
 * - 기본 키 제약 조건 : 1. null 2. unique 3. 불변성
 * *** 1,2번은 쉬우나 3번은 어려움. 서비스 생명이 다할 때까지의 미래를 만족시키는 '자연키'(비즈니스에 의미를 가지는 키 ex.주민번호 등)는 찾기 어렵다.
 * -> *** 비즈니스와 전혀 상관없는 * 대리키/대체키를 사용하자 ( 랜덤값, generatedValue, sequence 등등..)
 * 권장 - 타입은 Long형 + 대체키(시퀀스든 uuid든 랜덤이든) + 키 생성전략을 조합해서 사용
 * AUTO_INCREMENT or SEQUENCE OBJECT 둘 중 쓰는 것을 추천
 * 때에 따라 uuid or 랜덤값을 조합한 회사 내의 룰
 */

@Entity
//@SequenceGenerator(name = "member_seq_generator", sequenceName = "member_seq")
@TableGenerator(
        name = "MEMBER_SEQ_GENERATOR",
        table = "MY_TABLE_SEQUENCE",
        pkColumnValue = "MEMBER_SEQ",
        allocationSize = 1
)
public class BasicKeyMappingMember {

    // *** 기본 키 할당
    @Id //내가 값을 직접 할당하고 싶을 경우

    //@GeneratedValue
    // strategy
    //1. GenerationType.AUTO : DB 'dialect'에 따라서 자동 생성
    //2. GenerationType.IDENTITY : 기본 키 생성을 '특정' DB에 위임.
    //   H2Dialect 예시) create table BasicKeyMappingMember (
    //                         id varchar(255) *** 'generated by default as identity',
    //                         primary key (id)
    //                   )
    //    단점 : Mysql dialect일 경우에는 해당 부분이 auto_increment
    //3. GenerationType.SEQUENCE : 주로 Oracle DB에서 사용.
    //   * Sequence - 연속된 번호를 생성하는 일련의 객체
    //   - create에서 실행하면 테이블들을 drop한 후 'Hibernate: create sequence hibernate_sequence start with 1 increment by 1' 확인 가능
    //   - table들 생성한 후에 'call next value for hibernate_sequence'을 통해 sequence 값 획득 후 query 실행하는 것으로 예상
    //   * 기본적으로 hibernate_sequence를 사용
    //   **** table마다 다른 시퀀스를 관리하고 싶을 경우 - 'Entity객체에' @SequenceGenerator() + 'column'의 @GeneratedValue(generator = '')를 통해 매핑 가능
    //   ex) 엔터티 - @Entity @SequenceGenerator(name = "MEMBER_SEQ_GENERATOR", sequenceName = "MEMBER_SEQ", initialValue = 1, allocations = 1)
    //       컬럼 - @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "MEMBER_SEQ_GENERATOR)
    //       결과 - create 실행 drop 후 'Hibernate: create sequence member_seq start with 1 increment by 50'
    //           - table 생성 후 'call next value for member_seq'
    //4. GenerationType.TABLE : 테이블 전략. '키 생성 전용 테이블'을 두고 DB 시퀀스를 흉내내는 방법
    //   - 장점 : 모든 데이터베이스에 적용 가능 / 단점 : 별도의 테이블 구성, DB를 테이블을 직접 사용해야하는 과정에서의 문제발생가능성, 성능
    //@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "member_seq_generator")
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "MEMBER_SEQUENCE_GENERATOR")
    private Long id;
    // ******* int는 0이 존재하므로 X
    // Integer보다 Long이 공간을 2배 차지하겠지만, 전체 어플리케이션 수준에선 사용비용이 매우 적음
    // + 10억이 넘어갈 때, Integer에서 Long으로 타입을 바꾸는 것이 오히려 더 힘듦

    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
